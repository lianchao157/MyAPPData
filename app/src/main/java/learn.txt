1好看的菜单
https://www.cnblogs.com/x1aolata/p/11946505.html
https://www.cnblogs.com/x1aolata/p/11946505.html

2类似   泡在网上的日子代码
http://see-source.com/androidwidget/list.html?type=67

侧边菜单

3资源网站
https://blog.csdn.net/csdn576038874/article/details/81200674




4源码下载地址
http://codesocang.com/gn/xiangmu/
https://www.codesocang.com/gn/dianshang/list_420_2.html




5 contlin  代码
https://gitee.com/cxyzy1/tab-layout-demo

bannner  设置小圆点   详细说明
https://github.com/youth5201314/banner

https://github.com/luwei2012/banner

6
仿淘宝首页功能菜单实现可动态配置的进度展现
https://www.songma.com/news/txtlist_i61906v.html

https://blog.csdn.net/qq_35605213/article/details/106494803

7
glide  加载图片解释
https://blog.csdn.net/qq_33463102/article/details/55225816

8 加了一个代码 报异常
 java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first.
 解决方法
https://blog.csdn.net/qq_35584878/article/details/93038872


9  处理代码
https://blog.csdn.net/huangxiaominglipeng/article/details/52126933

2.0  升到3.0  依赖名称修改
https://blog.csdn.net/weixin_40845165/article/details/89213528


10  出现R文件爆红 不能运行

https://blog.csdn.net/qq_22859147/article/details/105136437



11  Gradle 4.10.1 requires Java 7 or later to run. You are currently using Java 6.



12 相关的代码配置   ---  gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https://services.gradle.org/distributions/gradle-4.4-all.zip

---gradle.properties
systemProp.https.proxyPort=8080
systemProp.http.proxyHost=android-mirror.bugly.qq.com
org.gradle.jvmargs=-Xmx2048m -XX\:MaxPermSize\=512m -XX\:+HeapDumpOnOutOfMemoryError -Dfile.encoding\=UTF-8
org.gradle.daemon=true
systemProp.https.proxyHost=android-mirror.bugly.qq.com
systemProp.http.proxyPort=8080

----  build.gradle
buildscript {
    repositories {
        google()
        jcenter()
        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}
    }



        dependencies {
            classpath 'com.android.tools.build:gradle:3.0.0'
//            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
//            classpath 'com.jakewharton:butterknife-gradle-plugin:8.4.0'
//        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
//
//        //1.自动化maven打包插件
//        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
//        //2.自动上传至Bintray平台插件
//        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0"
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}
    }
}


13   更改按钮选中状态
https://blog.csdn.net/lilihong0/article/details/80927136


14  一个页面显示多  recvcleview
https://www.zhihu.com/question/39304525/answer/80656470


  recyclewview  是设置  分割线   和item  间距

  15 application   详解
  https://blog.csdn.net/benbenxiongyuan/article/details/51669212
  1  和activity和server一样是一个系统组件    用来存储 信息    需要在mainfest的application标签中进行注册  签增加个name属性把自己的 Application的名字定入即可


  recycleview
    使用   添加头部  和底部   的布局加载更多和刷新
    https://blog.csdn.net/zheng_jiao/article/details/60954961?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase




    3   recycleview   实现  复杂布局


    https://www.cnblogs.com/zhujiabin/p/9288437.html
    https://www.cnblogs.com/zhujiabin/p/9288437.html


    自定义的listview  url   解决  scrowview 嵌套  不能划定



    4   Android  的 响应式布局
    就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。
    https://blog.csdn.net/cici_niuniu/article/details/89952331?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control
    和相应的githbu
    https://github.com/google/flexbox-layout
FlexboxLayout属性
flexDirecition 子元素在主轴的排列方向
app:flexDirection=”row” 默认值，水平方向，起点在左，从左到右。
app:flexDirection=”row_reverse” 和row属性相反，水平方向，从右到左，起点在右端。
app:flexDirection=”column” 主轴是竖直方向，起点在上端，从上到下。
app:flexDirection=”column_reverse” 和column相反，竖直方向，起点在下方从下到上
通过四张图的对比，是明显看出来各个属性的作用的


    5
    饺子视频播放器代码
    可以完全自定义UI和任何功能
    一行代码切换播放引擎，支持的视频格式和协议取决于播放引擎，android.media.MediaPlayer ijkplayer
    完美检测列表滑动
    可实现全屏播放，小窗播放
    能在ListView、ViewPager和ListView、ViewPager和Fragment等多重嵌套模式下全屏工作
    可以在加载、暂停、播放等各种状态中正常进入全屏和退出全屏
    多种视频适配屏幕的方式，可铺满全屏，可以全屏剪裁
    重力感应自动进入全屏
    全屏后手势修改进度和音量
    Home键退出界面暂停播放，返回界面继续播放
    WebView嵌套本地视频控件
    demo中添加视频缓存的例子


    shi'p视频 地址测试
    https://blog.csdn.net/qq_17497931/article/details/80824328
public void cpAssertVideoToLocalPath() {
        try {
            InputStream myInput;
            OutputStream myOutput = new FileOutputStream(Environment.getExternalStorageDirectory().getAbsolutePath() + "/DCIM/Camera/local_video.mp4");
            myInput = this.getAssets().open("local_video.mp4");
            byte[] buffer = new byte[1024];
            int length = myInput.read(buffer);
            while (length > 0) {
                myOutput.write(buffer, 0, length);
                length = myInput.read(buffer);
            }

            myOutput.flush();
            myInput.close();
            myOutput.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
myJzvdStd.setUp(Environment.getExternalStorageDirectory().getAbsolutePath() + "/DCIM/Camera/local_video.mp4", "饺子不信",Jzvd.SCREEN_WINDOW_NORMAL, );
这里很多人问为什么播不了，请认真怒url，播不了就是url没怒对


 复制Demo中CustomMediaPlayerAssertFolder类到你的项目下
        ----------------------------------------------------------------------------
        JZDataSource jzDataSource = null;
        try {
            jzDataSource = new JZDataSource(getAssets().openFd("local_video.mp4"));
            jzDataSource.title = "饺子快长大";
        } catch (IOException e) {
            e.printStackTrace();
        }
        jzvdStd.setUp(jzDataSource, JzvdStd.SCREEN_WINDOW_NORMAL);
        Glide.with(this)
                .load("http://jzvd-pic.nathen.cn/jzvd-pic/1bb2ebbe-140d-4e2e-abd2-9e7e564f71ac.png")
                .into(jzvdStd.thumbImageView);

        Jzvd.setMediaInterface(new CustomMediaPlayerAssertFolder());//进入此页面修改MediaInterface，让此页面的jzvd正常工作
        -----------------------------------------------------------------------------

        JzvdStd.startFullscreen(this, JzvdStd.class, VideoConstant.videoUrlList[6], "饺子辛苦了");
        直接全屏播放
        JzvdStd.startFullscreen(this, JzvdStd.class, VideoConstant.videoUrlList[6], "饺子辛苦了");
        直接全屏播放

        JzvdStd.startFullscreen(this, JzvdStd.class, VideoConstant.videoUrlList[6], "饺子辛苦了");
        开启小窗播放

        mJzvdStd.startWindowTiny();

        列表Item划出开启小窗播放

        1.Listview
           listView.setOnScrollListener(new AbsListView.OnScrollListener() {
                    @Override
                    public void onScrollStateChanged(AbsListView view, int scrollState) {

                    }
                    @Override
                    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                        Jzvd.onScrollAutoTiny(view, firstVisibleItem, visibleItemCount, totalItemCount);
                      // Jzvd.onScrollReleaseAllVideos(view, firstVisibleItem, visibleItemCount, totalItemCount);  这是不开启列表划出小窗 同时也是画出屏幕释放JZ 划出暂停
                    }
                });
        2. RecyclerView  划出列表开启小窗
           recyclerView.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() {
                    @Override
                    public void onChildViewAttachedToWindow(View view) {
                        Jzvd.onChildViewAttachedToWindow(view, R.id.videoplayer);
                    }

                    @Override
                    public void onChildViewDetachedFromWindow(View view) {
                        Jzvd.onChildViewDetachedFromWindow(view);
                    }
                });
        2.1 RecyclerView划出屏幕释放JZ，同时也是不开启列表划出显示小窗
            recyclerView.addOnChildAttachStateChangeListener(new RecyclerView.OnChildAttachStateChangeListener() {
                    @Override
                    public void onChildViewAttachedToWindow(View view) {

                    }

                    @Override
                    public void onChildViewDetachedFromWindow(View view) {
                        Jzvd jzvd = view.findViewById(R.id.videoplayer);
                        if (jzvd != null && jzvd.jzDataSource.containsTheUrl(JZMediaManager.getCurrentUrl())) {
                            Jzvd currentJzvd = JzvdMgr.getCurrentJzvd();
                            if (currentJzvd != null && currentJzvd.currentScreen != Jzvd.SCREEN_WINDOW_FULLSCREEN) {
                                Jzvd.releaseAllVideos();
                            }
                        }
                    }
                });


  recycleview
     混合布局
     https://blog.csdn.net/asjqkkkk/article/details/78489245


layout_flexBasisPercent
layout_flexBasisPercent 属性定义了在分配多余空间之前，子元素占据的主轴空间的百分比。它的默认值为auto，即子元素的本来大小。


类似weight
layout_flexGrow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。其实就是 LinearLayout 中的weight属性，如果所有项目的layout_flexGrow 属性都为1，则它们将等分剩余空间。如果一个项目的layout_flexGrow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

自定义适应放大或者缩小
layout_flexShrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小（设置了换行则无效）。如果所有项目的 layout_flexShrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。

作者：锐心凌志
链接：https://www.jianshu.com/p/5224af72987e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


作者：锐心凌志
链接：https://www.jianshu.com/p/5224af72987e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


toobar


我们从下往上说明：

1.navigationBarColor:这个是控制底部导航栏背景颜色的属性，而且仅在android 5.0以上版生效，低于API 21 版本无效。

2.windowBackground:顾名思义主视图窗体的背景颜色。

3.ToolBar:background:工具栏ToolBar的背景颜色，只需在布局文件设置即可

4.colorPrimaryDark:状态栏的背景颜色，在style.xml中设置






android 的  流式布局
https://blog.csdn.net/lmj623565791/article/details/38352503
https://www.jianshu.com/p/b3a9c4a99053   //  简书  详细代码

案例代码和重要
https://blog.csdn.net/lmj623565791



首次进入后 操作提示
https://blog.csdn.net/fuweiping/article/details/8082153
主要思想用shareprace    记录是否第一次进入程序  是则显示  操作提示的  背景 图片 不是 则记录并进行隐藏


打包的密码都是111111

https://blog.csdn.net/ffengz/article/details/52667649
Android 开关控件Switch的简单使用
 <Switch
        android:id="@+id/switch_普通开关"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />


 ANDROID  Dagger2从入门到放弃再到恍然大悟   依赖注入  依赖注入 依赖注入
https://www.jianshu.com/p/39d1df6c877d
https://github.com/thinkSky1206/MVP-Dagger2-Retrofit




2021.3.22  mvp 实现网络请求  获取快递到哪了

存在问题   实体类显示数据不全


2021.3.22  fragmtne  的嵌套
https://www.easck.com/cos/2019/1214/445944.shtml   三页 感觉可用


https://blog.csdn.net/csdn_mm/article/details/80918323?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.control

2021.3.23  listview 实现  listview 拼音人民列表排序
https://www.jianshu.com/p/b7091e43c971

2021.3.23
recycleview  实现瀑瀑流的效果
StaggeredGridLayoutManager layout = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
rv.setLayoutManager(layout);



https://blog.csdn.net/weixin_45697390/article/details/107134542   仿抖音上下滑动切换视频


2
https://blog.csdn.net/qq_34068563/article/details/103558295?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.control&dist_request_id=1328679.66031.16165007694868623&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.control

Android 仿抖音上下滑动布局


待做  这个个 HotFFragment   刷新组件出现报错


databingview  可以一次性引用多个组件
buildgradle中添加
buildfeatures{
viewBinding=true}

在activity 中添加
lateinit var  binding :
作用保证初试话
oncreate（）下
binding=ActivityMainBinding.inflate(layoutInflater)// 膨胀扩大， 充气机

xxxx
setContentView(binding.root)
//  发现组件
binding.buttoncalculate.setOnclick


上传码云代码
https://blog.csdn.net/xiaoxiaobai250/article/details/88327061


10  retorfit  的封装
https://blog.csdn.net/chentaishan/article/details/105654328


11  2021.4.23  先把屏幕适配做好


12
picaso 的使用
https://blog.csdn.net/alvinhuai/article/details/82228734前言
                                                              上一篇博客picasso使用详解（一）详细介绍了picasso的各种使用方法与他的一些特性，这次从源码的角度详细讲解他的流程和原理。它的整体流程可以分为2个部分，一个是设置加载条件，确定需要展示的图片的各种属性，第二是加载然后对图片进行实际的处理，然后显示到目标对象上。

                                                        流程简介
                                                             picasso加载图片的整体流程其实可以看成是事件分发的机制，首先通过设置url与其他属性，封装一个完成的请求，然后通过入队分发从而每个具体的线程得以执行，执行完毕从服务器获取数据，解码生成bitmap，然后处理各种属性需求（圆角，变换，倒影），再通过分发得以显示。所以大致流程可以简化为：

                                                             封装需求-->入队分发-->请求服务器-->获取数据解码处理属性-->分发显示

                                                             下图来自codekk源码分析系列，不是原创，能清晰的表示流程。

                                                             

                                                        源码分析
                                                             picasso可以处理多种形式的图片加载，在此我们使用最常见的网络请求作为例子进行分析，其他几种形式大同小异。

                                                             首先通过Picasso.get()函数可以得到一个picasso的单例对象，我们来看picasso的构造函数：

                                                         Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,
                                                              RequestTransformer requestTransformer, List<RequestHandler> extraRequestHandlers, Stats stats,
                                                              Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) {
                                                            this.context = context;
                                                            this.dispatcher = dispatcher;
                                                            this.cache = cache;
                                                            this.listener = listener;
                                                            this.requestTransformer = requestTransformer;
                                                            this.defaultBitmapConfig = defaultBitmapConfig;

                                                            int builtInHandlers = 7; // Adjust this as internal handlers are added or removed.
                                                            int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0);
                                                            List<RequestHandler> allRequestHandlers = new ArrayList<>(builtInHandlers + extraCount);

                                                            // ResourceRequestHandler needs to be the first in the list to avoid
                                                            // forcing other RequestHandlers to perform null checks on request.uri
                                                            // to cover the (request.resourceId != 0) case.
                                                            allRequestHandlers.add(new ResourceRequestHandler(context));
                                                            if (extraRequestHandlers != null) {
                                                              allRequestHandlers.addAll(extraRequestHandlers);
                                                            }
                                                            allRequestHandlers.add(new ContactsPhotoRequestHandler(context));
                                                            allRequestHandlers.add(new MediaStoreRequestHandler(context));
                                                            allRequestHandlers.add(new ContentStreamRequestHandler(context));
                                                            allRequestHandlers.add(new AssetRequestHandler(context));
                                                            allRequestHandlers.add(new FileRequestHandler(context));
                                                            allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));
                                                            requestHandlers = Collections.unmodifiableList(allRequestHandlers);

                                                            this.stats = stats;
                                                            this.targetToAction = new WeakHashMap<>();
                                                            this.targetToDeferredRequestCreator = new WeakHashMap<>();
                                                            this.indicatorsEnabled = indicatorsEnabled;
                                                            this.loggingEnabled = loggingEnabled;
                                                            this.referenceQueue = new ReferenceQueue<>();
                                                            this.cleanupThread = new CleanupThread(referenceQueue, HANDLER);
                                                            this.cleanupThread.start();
                                                          }
                                                             需要的参数比较多，我们只是选择几个比较重要的说说，否则就不是一篇博客可以说的完了。其中的dispatcher是负责分发请求的，cache是picasso的缓存机制，通过add添加的各种RequestHandler通是继承自抽象类RequestHandler，通过不同的requesthandler来处理不同类型的图片，我们也可以自定义requesthandler。看了构造函数，我们就要看它的实现方式了，picasso和很多工具一样通过bulider的模式来创建实例。

                                                        public Picasso build() {
                                                              Context context = this.context;

                                                              if (downloader == null) {
                                                                //默认使用的就是ok的下载器
                                                                downloader = new OkHttp3Downloader(context);
                                                              }
                                                              if (cache == null) {
                                                                //缓存大小为app内存大小的15%
                                                                cache = new LruCache(context);
                                                              }
                                                              if (service == null) {
                                                                //picasso自定义的线程池，目前容量是3，会根据网络情况而变化
                                                                service = new PicassoExecutorService();
                                                              }
                                                              if (transformer == null) {
                                                                //默认不做任何变换
                                                                transformer = RequestTransformer.IDENTITY;
                                                              }

                                                              //用于统计缓存以及命中率，在本博客暂不深入分析
                                                              Stats stats = new Stats(cache);

                                                              //分发器用于各个任务的调度处理，HANDLER就是主线程的handler，必须通过它sendmessage来进行
                                                              // target的图片显示。
                                                              Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

                                                              //生成picasso实例
                                                              return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
                                                                  defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
                                                            }
                                                                通过build()函数生成Picasso实例，我们看出downloader模块，线程池模块，lru缓存都是在这里进行初始化，所有的这些参数我们都是可以自定义来适应我们项目的需求，自定义的缓存，下载，线程池等模块都可以通过set()函数来设置。获取实例之后，接下来看load方法。

                                                         public RequestCreator load(@Nullable Uri uri) {
                                                            return new RequestCreator(this, uri, 0);
                                                          }
                                                               可以看到其实load方法最终的目的是生成一个RequestCreator，RequestCreator的作用就是提供了一些列api设置请求图片这个需求的各种属性（比如大小重置，旋转情况，请求优先级属性，是否变换），然后生成一个真正的请求。我们可以通过看Requestcreator的构造函数：

                                                         RequestCreator(Picasso picasso, Uri uri, int resourceId) {
                                                            if (picasso.shutdown) {
                                                              throw new IllegalStateException(
                                                                  "Picasso instance already shut down. Cannot submit new requests.");
                                                            }
                                                            this.picasso = picasso;
                                                            this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);
                                                          }

                                                        //以下是Request类中的Builder的构造函数
                                                        private Builder(Request request) {
                                                              //加载图片的uri
                                                              uri = request.uri;

                                                              //如果加载的是本地resource，那么这个id不为空
                                                              resourceId = request.resourceId;

                                                              stableKey = request.stableKey;
                                                              targetWidth = request.targetWidth;
                                                              targetHeight = request.targetHeight;
                                                              centerCrop = request.centerCrop;
                                                              centerInside = request.centerInside;
                                                              centerCropGravity = request.centerCropGravity;
                                                              rotationDegrees = request.rotationDegrees;
                                                              rotationPivotX = request.rotationPivotX;
                                                              rotationPivotY = request.rotationPivotY;
                                                              hasRotationPivot = request.hasRotationPivot;
                                                              purgeable = request.purgeable;
                                                              onlyScaleDown = request.onlyScaleDown;
                                                              if (request.transformations != null) {
                                                                transformations = new ArrayList<>(request.transformations);
                                                              }
                                                              config = request.config;
                                                              priority = request.priority;
                                                            }
                                                               可以看出Request的builder也是一些属性的描述。所以request的一个纯粹的关于请求对象的描述。 在into之前都是对请求的描述，设置各种属相。然后生成了Request，然后就看into函数。

                                                         public void into(ImageView target, Callback callback) {
                                                            long started = System.nanoTime();

                                                            //检查是否是主线程。如果不是则抛出异常
                                                            checkMain();

                                                            //target如果是空，也抛出异常
                                                            if (target == null) {
                                                              throw new IllegalArgumentException("Target must not be null.");
                                                            }

                                                            //这里是检测需要加载的图片是否包含url或者resourceid，都为空在取消请求，
                                                            //如果有占位图就直接显示占位图
                                                            if (!data.hasImage()) {
                                                              picasso.cancelRequest(target);
                                                              if (setPlaceholder) {
                                                                setPlaceholder(target, getPlaceholderDrawable());
                                                              }
                                                              return;
                                                            }

                                                            //是否选择了fit模式，如果选择了需要计算图片的大小，然后进行重置
                                                            //所以如果设置了fit模式，imageview的大小不能用wrap_content设置否则抛出异常
                                                            if (deferred) {
                                                              if (data.hasSize()) {
                                                                throw new IllegalStateException("Fit cannot be used with resize.");
                                                              }
                                                              int width = target.getWidth();
                                                              int height = target.getHeight();
                                                              if (width == 0 || height == 0) {
                                                                if (setPlaceholder) {
                                                                  setPlaceholder(target, getPlaceholderDrawable());
                                                                }
                                                                picasso.defer(target, new DeferredRequestCreator(this, target, callback));
                                                                return;
                                                              }
                                                              data.resize(width, height);
                                                            }

                                                            //构建request和requestkey
                                                            Request request = createRequest(started);
                                                            String requestKey = createKey(request);

                                                            //根据memorypolicy来确认是否可以直接从内存读取。
                                                            if (shouldReadFromMemoryCache(memoryPolicy)) {
                                                              Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
                                                              if (bitmap != null) {
                                                                picasso.cancelRequest(target);
                                                                setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
                                                                if (picasso.loggingEnabled) {
                                                                  log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + MEMORY);
                                                                }
                                                                if (callback != null) {
                                                                  callback.onSuccess();
                                                                }
                                                                return;
                                                              }
                                                            }

                                                            //  创建action，action才是最终会提交到队列中的对象，因为处理之后需要回传数据，所以不能
                                                            //仅仅是提交一个request到队列。我们更需要的是结果。
                                                            Action action =
                                                                new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
                                                                    errorDrawable, requestKey, tag, callback, noFade);

                                                            picasso.enqueueAndSubmit(action);
                                                          }
                                                                 我们可以看到，最终提交的是一个Action，Action也是一个抽象类，会根据我们不同的请求生成不同的action子类，他不但包含了请求信息，还包含了回调接口，所以他要包含picasso的实例。如果是一次要加载多个图片，那么会产生多个request和多个aciton，可以看Action类中有关于释放内存的措施。

                                                         static class RequestWeakReference<M> extends WeakReference<M> {
                                                            final Action action;

                                                            RequestWeakReference(Action action, M referent, ReferenceQueue<? super M> q) {
                                                              super(referent, q);
                                                              this.action = action;
                                                            }
                                                          }
                                                           //成成的target都是弱引用，会及时释放内存，避免长时间加载造成的内存占用过多。
                                                          final WeakReference<T> target;
                                                              接下来我们继续看sbumit之后的操作，通过dispatcher分发，

                                                        void submit(Action action) {
                                                            //添加到队列中去。
                                                            dispatcher.dispatchSubmit(action);
                                                        }

                                                        //这是dispatcher初始化的情况
                                                        Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

                                                        // 这里是dispatcher类的情况，省略一部分代码


                                                          final DispatcherThread dispatcherThread;
                                                          final Context context;

                                                          //线程池，支持自定义
                                                          final ExecutorService service;

                                                          //下载接口
                                                          final Downloader downloader;

                                                          //BitmapHunter实现了Runnable接口，这个才是网络请求核心类，实现了下载，解码，对bitmap进行
                                                          //编辑，提交到线程池的最小单位。这个map保存了所有的请求。
                                                          final Map<String, BitmapHunter> hunterMap;

                                                          //保存了失败的action
                                                          final Map<Object, Action> failedActions;

                                                          //保存了暂停的action
                                                          final Map<Object, Action> pausedActions;
                                                          //暂停tag
                                                          final Set<Object> pausedTags;

                                                          //自己内部的handler，分发请求线程的时候，就是通过这个自己线程内部的handler进行分发
                                                          final Handler handler;

                                                          //主线程handler，因为dispather不止是负责将请求的线程提交到线程池。还需要将请求的结果分发
                                                          //到目标来进行显示，所以必须包含主线程的handler
                                                          final Handler mainThreadHandler;
                                                          final Cache cache;
                                                          final Stats stats;
                                                          final List<BitmapHunter> batch;
                                                          final NetworkBroadcastReceiver receiver;
                                                          final boolean scansNetworkChanges;

                                                          boolean airplaneMode;

                                                          Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler,
                                                              Downloader downloader, Cache cache, Stats stats) {
                                                            this.dispatcherThread = new DispatcherThread();
                                                            this.dispatcherThread.start();
                                                            this.hunterMap = new LinkedHashMap<>();
                                                            this.failedActions = new WeakHashMap<>();
                                                            this.pausedActions = new WeakHashMap<>();
                                                            this.pausedTags = new LinkedHashSet<>();
                                                            this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);
                                                            this.downloader = downloader;
                                                            this.mainThreadHandler = mainThreadHandler;

                                                          }
                                                            一步步查看我们会发现submit最终调用的是如下：这里的handler就是dispatcher类中线程的handler

                                                        //这就是dispatcher类中的submit函数，使用的handler就是线程自己的handler
                                                        void dispatchSubmit(Action action) {
                                                            handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
                                                          }
                                                            发送消息之后我们来看消息的处理函数：

                                                         void performSubmit(Action action, boolean dismissFailed) {

                                                            //检测暂停的请求是否包含此次请求，如果包含，将请求保存到map，返回。
                                                            if (pausedTags.contains(action.getTag())) {
                                                              pausedActions.put(action.getTarget(), action);
                                                              if (action.getPicasso().loggingEnabled) {
                                                                log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),
                                                                    "because tag '" + action.getTag() + "' is paused");
                                                              }
                                                              return;
                                                            }

                                                            //检测已经提交的请求是否包含此次请求，key就是根据url或者resourceid
                                                            //这样的字段生成，如果已经包含了同样的请求，那么直接合并到同一个hunter中去。
                                                            //bitmaphunter实现了runnable接口，这个类是最终请求网路并进行编码生成bitmap的类。

                                                            BitmapHunter hunter = hunterMap.get(action.getKey());
                                                            if (hunter != null) {
                                                              hunter.attach(action);
                                                              return;
                                                            }

                                                            if (service.isShutdown()) {
                                                              if (action.getPicasso().loggingEnabled) {
                                                                log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), "because shut down");
                                                              }
                                                              return;
                                                            }

                                                            //在这里生成一个bitmaphunter
                                                            hunter = forRequest(action.getPicasso(), this, cache, stats, action);

                                                            //获取返回的结果。
                                                            hunter.future = service.submit(hunter);

                                                            //保存到map中
                                                            hunterMap.put(action.getKey(), hunter);
                                                            if (dismissFailed) {
                                                              failedActions.remove(action.getTarget());
                                                            }

                                                            if (action.getPicasso().loggingEnabled) {
                                                              log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());
                                                            }
                                                          }
                                                           在perform中主要是获取到真正需要处理的bitmaphunter，让它执行并且获取到线程的结果。我们可以下forRequest函数

                                                         static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
                                                              Action action) {
                                                            Request request = action.getRequest();
                                                            List<RequestHandler> requestHandlers = picasso.getRequestHandlers();

                                                             //此函数的核心在于这里，根据request的不同，选择匹配的requesthandler
                                                             //所有的requesthandler都继承抽象类requestHandler,其中的核心方法是load
                                                             //根据不同的图片来源选择不同的加载方式，比如assets文件夹中的图片和网络图片的加载方式肯定不一样
                                                             //加载网络图片用的是NetworkRequestHandler
                                                             //对于这个请求不确定性和多个处理器都有机会处理的请情况，可以看做是责任连模式的简单应用

                                                            for (int i = 0, count = requestHandlers.size(); i < count; i++) {
                                                              RequestHandler requestHandler = requestHandlers.get(i);
                                                              if (requestHandler.canHandleRequest(request)) {
                                                                return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
                                                              }
                                                            }

                                                            return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);
                                                          }
                                                            回头看performsubmit函数，执行了submit之后，按照顺序一年执行bitmaphunter中的run函数了。

                                                         @Override public void run() {
                                                            try {
                                                              //更新线程名
                                                              updateThreadName(data);

                                                              if (picasso.loggingEnabled) {
                                                                log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this));
                                                              }

                                                              //执行并且返回结果result包含了返回的图片的bitmap，drawable信息
                                                              result = hunt();

                                                              //执行完之后通过dispatcher在进行分发。result是全局变量，这样当分发之后，
                                                              //回到函数可以通过result来获取返回的最终结果， this确保了每个对象获取自己
                                                              //所需要的结果。

                                                              if (!result.hasBitmap()) {
                                                                dispatcher.dispatchFailed(this);
                                                              } else {
                                                                dispatcher.dispatchComplete(this);
                                                              }
                                                            } finally {
                                                              Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);
                                                            }
                                                          }


                                                        Result hunt() throws IOException {
                                                            //是否是内存模式读取
                                                            if (shouldReadFromMemoryCache(data.memoryPolicy)) {
                                                              Bitmap bitmap = cache.get(key);
                                                              if (bitmap != null) {
                                                                stats.dispatchCacheHit();
                                                                if (picasso.loggingEnabled) {
                                                                  log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache");
                                                                }
                                                                return new Result(bitmap, MEMORY);
                                                              }
                                                            }

                                                            //确认重连次数
                                                            if (retryCount == 0) {
                                                              data = data.newBuilder().networkPolicy(NetworkPolicy.OFFLINE).build();
                                                            }

                                                            final AtomicReference<Result> resultReference = new AtomicReference<>();
                                                            final AtomicReference<Throwable> exceptionReference = new AtomicReference<>();
                                                            final CountDownLatch latch = new CountDownLatch(1);
                                                            try {
                                                              //在本例中因为是网络请求，使用的是NetworkRequestHandler， 这是通过查看
                                                              //其中的load会得知使用的完全是okhttp的下载方法。

                                                              requestHandler.load(picasso, data, new RequestHandler.Callback() {
                                                                @Override public void onSuccess(@Nullable Result result) {
                                                                  resultReference.set(result);
                                                                  latch.countDown();
                                                                }

                                                                @Override public void onError(@NonNull Throwable t) {
                                                                  exceptionReference.set(t);
                                                                  latch.countDown();
                                                                }
                                                              });

                                                              latch.await();
                                                            } catch (InterruptedException ie) {
                                                              InterruptedIOException interruptedIoException = new InterruptedIOException();
                                                              interruptedIoException.initCause(ie);
                                                              throw interruptedIoException;
                                                            }

                                                            //如果出现异常。则抛出
                                                            Throwable throwable = exceptionReference.get();
                                                            if (throwable != null) {
                                                              if (throwable instanceof IOException) {
                                                                throw (IOException) throwable;
                                                              }
                                                              if (throwable instanceof Error) {
                                                                throw (Error) throwable;
                                                              }
                                                              if (throwable instanceof RuntimeException) {
                                                                throw (RuntimeException) throwable;
                                                              }
                                                              throw new RuntimeException(throwable);
                                                            }

                                                            Result result = resultReference.get();

                                                            if (result.hasBitmap()) {
                                                              if (picasso.loggingEnabled) {
                                                                log(OWNER_HUNTER, VERB_DECODED, data.logId());
                                                              }
                                                              Bitmap bitmap = result.getBitmap();
                                                              stats.dispatchBitmapDecoded(bitmap);

                                                              //根据需求对bitmap进行剪裁
                                                              int exifOrientation = result.getExifRotation();
                                                              if (data.needsTransformation() || exifOrientation != 0) {
                                                                if (data.needsMatrixTransform() || exifOrientation != 0) {
                                                                  bitmap = transformResult(data, bitmap, exifOrientation);
                                                                  if (picasso.loggingEnabled) {
                                                                    log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());
                                                                  }
                                                                }

                                                                //如果设置了transFrom那么进行变换。
                                                                result = new Result(bitmap, result.getLoadedFrom(), exifOrientation);
                                                                if (data.hasCustomTransformations()) {
                                                                  result = applyCustomTransformations(data.transformations, result);
                                                                  if (picasso.loggingEnabled) {
                                                                    log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(),
                                                                        "from custom transformations");
                                                                  }
                                                                }
                                                              }
                                                              if (result.hasBitmap()) {
                                                                stats.dispatchBitmapTransformed(result.getBitmap());
                                                              }
                                                            }

                                                            return result;
                                                          }
                                                           整体流程是通过hunt中的load方法获取到了需要的bitmap，然后查看各种属性配置，是否需要对bitmap做额外的处理， 再此处的一些异常处理机制忽略大家可以自己看看。处理完之后，通过dispatcher将结果分发出去。通过dispatcher类中的handler分发。dispatcher.dispatchComplete最终也会执行到dispatcher.performComplete 方法。

                                                         void performComplete(BitmapHunter hunter) {
                                                            //是否需要写入缓存
                                                            if (shouldWriteToMemoryCache(hunter.data.memoryPolicy)) {
                                                              RequestHandler.Result result = hunter.getResult();
                                                              if (result.hasBitmap()) {
                                                                cache.set(hunter.getKey(), result.getBitmap());
                                                              }
                                                            }

                                                            //讲求结束，将hunter在map中删除
                                                            hunterMap.remove(hunter.getKey());

                                                            //处理hunter，在最新代码中，此处已经做改变。
                                                              batch(hunter);
                                                            if (hunter.getPicasso().loggingEnabled) {
                                                              log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), "for completion");
                                                            }
                                                          }
                                                           batch函数，最终执行到

                                                         void performBatchComplete() {
                                                            List<BitmapHunter> copy = new ArrayList<>(batch);
                                                            batch.clear();
                                                            //将执行结果通过主线程handler分发
                                                            mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
                                                            logBatch(copy);
                                                          }
                                                        主线程handler的处理方式

                                                        static final Handler HANDLER = new Handler(Looper.getMainLooper()) {
                                                            @Override public void handleMessage(Message msg) {
                                                              switch (msg.what) {
                                                                case HUNTER_BATCH_COMPLETE: {
                                                                  //获取bitmaphunter的结果
                                                                  @SuppressWarnings("unchecked") List<BitmapHunter> batch = (List<BitmapHunter>) msg.obj;
                                                                  //noinspection ForLoopReplaceableByForEach
                                                                  for (int i = 0, n = batch.size(); i < n; i++) {
                                                                    BitmapHunter hunter = batch.get(i);

                                                                    //必须是hunter.picasso中的对应picasso，来处理结果
                                                                    hunter.picasso.complete(hunter);
                                                                  }
                                                                  break;
                                                         }


                                                        //complete函数如下：

                                                        void complete(BitmapHunter hunter) {
                                                            //获取单个的action
                                                            Action single = hunter.getAction();

                                                            //获取被合并进来的action，上面的performsubmit内容描述过，遇到同样的请求，会合并。

                                                            List<Action> joined = hunter.getActions();

                                                            boolean hasMultiple = joined != null && !joined.isEmpty();
                                                            boolean shouldDeliver = single != null || hasMultiple;

                                                            if (!shouldDeliver) {
                                                              return;
                                                            }

                                                            Uri uri = hunter.getData().uri;
                                                            Exception exception = hunter.getException();
                                                            Bitmap result = hunter.getResult();
                                                            LoadedFrom from = hunter.getLoadedFrom();

                                                            if (single != null) {
                                                              //最终都是通过此函数将需要分发的结果处理掉
                                                              deliverAction(result, from, single, exception);
                                                            }

                                                            if (hasMultiple) {
                                                              //noinspection ForLoopReplaceableByForEach
                                                              for (int i = 0, n = joined.size(); i < n; i++) {
                                                                Action join = joined.get(i);
                                                                deliverAction(result, from, join, exception);
                                                              }
                                                            }

                                                            if (listener != null && exception != null) {
                                                              listener.onImageLoadFailed(this, uri, exception);
                                                            }
                                                          }
                                                           所以按照顺序进入deliverAction函数

                                                         private void deliverAction(Bitmap result, LoadedFrom from, Action action, Exception e) {
                                                            if (action.isCancelled()) {
                                                              return;
                                                            }
                                                            if (!action.willReplay()) {
                                                              targetToAction.remove(action.getTarget());
                                                            }
                                                            if (result != null) {
                                                              if (from == null) {
                                                                throw new AssertionError("LoadedFrom cannot be null.");
                                                              }
                                                              //核心的在这里，调用了action的complete，我们知道使用的是Imageviewaction,所以直接去查看
                                                              action.complete(result, from);
                                                              if (loggingEnabled) {
                                                                log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), "from " + from);
                                                              }
                                                            } else {
                                                              action.error(e);
                                                              if (loggingEnabled) {
                                                                log(OWNER_MAIN, VERB_ERRORED, action.request.logId(), e.getMessage());
                                                              }
                                                            }
                                                          }


                                                        //imageviewAction的complete方法
                                                        @Override public void complete(RequestHandler.Result result) {
                                                            if (result == null) {
                                                              throw new AssertionError(
                                                                  String.format("Attempted to complete action with no result!\n%s", this));
                                                            }

                                                            ImageView target = this.target.get();
                                                            if (target == null) {
                                                              return;
                                                            }

                                                            Context context = picasso.context;
                                                            boolean indicatorsEnabled = picasso.indicatorsEnabled;
                                                            //通过PicassonDrawable来设置获取到的bitmap到目标imageview
                                                            PicassoDrawable.setResult(target, context, result, wrapper.noFade, indicatorsEnabled);

                                                            //回调接口，这个接口是通过into(String url, CallBack callback)进行设置的，可为空
                                                            if (callback != null) {
                                                              callback.onSuccess();
                                                            }
                                                          }
                                                        在这里PicassoDrawable继承自Drawable，它重写了ondraw方法，通过设置可以显示左上角表示图片来源的三角。我们可以看setResult函数

                                                        static void setResult(ImageView target, Context context, RequestHandler.Result result,
                                                              boolean noFade, boolean debugging) {
                                                            //获取占位图
                                                            Drawable placeholder = target.getDrawable();
                                                            if (placeholder instanceof Animatable) {
                                                              //如果是动画，则停止
                                                              ((Animatable) placeholder).stop();
                                                            }
                                                            if (result.hasBitmap()) {
                                                              Picasso.LoadedFrom loadedFrom = result.getLoadedFrom();
                                                              Bitmap bitmap = result.getBitmap();
                                                              PicassoDrawable drawable =
                                                                  new PicassoDrawable(context, bitmap, placeholder, loadedFrom, noFade, debugging);

                                                              //target也就是imageview，到此真正显示了图片
                                                              target.setImageDrawable(drawable);
                                                            } else if (result.hasDrawable()) {
                                                              Drawable drawable = result.getDrawable();

                                                              //设置drawable，如果是动画开始
                                                              target.setImageDrawable(drawable);
                                                              if (drawable instanceof Animatable) {
                                                                ((Animatable) drawable).start();
                                                              }
                                                            }
                                                          }
                                                           到此加载图片的整个流程就算结束了。由于篇幅所限，只是书序的描述了一下流程，其中还有缓存，暂停等其他策略没有一一介绍。会在后面的文章中做出分析。
                                                        ————————————————
                                                        版权声明：本文为CSDN博主「雨打瓦」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
                                                        原文链接：https://blog.csdn.net/alvinhuai/article/details/82228734
														
														
														
														
														
														
														
														
Android  6.0  动态权限问题
ContextCompat.checkSelfPermission
检查应用是否具有某个危险权限。如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PackageManager.PERMISSION_DENIED，且应用必须明确向用户要求权限。

ActivityCompat.requestPermissions
应用可以通过这个方法动态申请权限，调用后会弹出一个对话框提示用户授权所申请的权限。

ActivityCompat.shouldShowRequestPermissionRationale
如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don't ask again 选项，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。

onRequestPermissionsResult
当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 onRequestPermissionsResult() 方法，向其传递用户响应，处理对应的场景。


链接：https://www.jianshu.com/p/2fe4fb3e8ce0
<uses-permission android:name="android.permission.READ_CONTACTS" />


	2021.7.15
	数据库操作
	http://c.biancheng.net/view/3112.html




	2021,7.28   无网络时 配置 和相应的显示
	https://blog.csdn.net/qq_34115167/article/details/80719219

	各种工具类的合集
	https://www.jianshu.com/nb/15490503


	仿写淘宝页面
	https://github.com/LiQinglin007/PullToLoadMoreView-master/blob/master/app/build.gradle
